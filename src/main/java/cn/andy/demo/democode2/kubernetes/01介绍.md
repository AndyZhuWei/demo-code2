# 容器编排与Kubernetes(K8s)
## 集群环境容器部署的困境
![集群环境容器部署的困境](images\集群环境容器部署的困境.jpg)
在之前，我们用Docker构建了一系列的应用《架构师必备技能docker入口到专精.md》
单独使用Docker很简单运维也简单，但是设备数量一多就很麻烦。尤其是面对大集群的环境
而且，现在如果有10台机器要部署的时候我们确实需要一下都部署嘛，因为平时流量可能没有那么大，在有活动的是时候在部署其他，这样可以节省电费和机柜租赁费用，
但是这些都需要人工来做嘛？而且这里如果不仅仅是10台而是想大厂10w台呢？
所以在实际工作中，大厂都是使用一些支持集群的容器编排工具来自动化完成集群构建与部署
* 容器编排：在哪些宿主机上安装哪些容器，以及这些宿主机以什么方式来进行通信和被管理的。这肯定要依托于一些工具，这些工具就是容器编排工具

## 容器编排工具比较
![容器编排工具比较](images\容器编排工具比较.jpg)
Docker SWARM是Docker官方推出地，本来基于厚望，但是
半路杀出一个强有力的竞争对手Kubernetes,英文简称K8s
![kubernetes](images\kubernetes.jpg)
k8s是谷歌推出的一个容器编排工具，底层完成基于Docker，它和Docker SWARE是竞争对手的关系
k8s有一个比较明显的优势就是是谷歌自己的产品，谷歌本身就有多年的运维开发经验，所以这个工具是经过大量的实践，以及大量的宿主机验证通过的
是非常成熟的。因此k8s比较有优势。现在已经被k8s统一。
## Kubernetes的职责
* 自动化容器的部署和复制
  我们只需要通过脚本规划好容器在哪些主机上运行，运行多少个副本，k8s就会自动根据配置自动在对应主机上安装
* 随时扩展或收缩容器规模
  可以是人工也可以是自动地
* 容器分组Group,并且提供容器间的负载均衡
  之前通过nginx来做，现在完全可以交给k8s
* 实时监控，即时故障发现，自动替换
   提供了管理界面
  
#Kubernetes基本概念
![Kubernetes基本概念](images\kubernetes基本概念.jpg)

左图地每一个方块都是一台物理的宿主机，共有3台宿主机，这3台宿主机形成一个完整的集群。
从角色划分，有两种角色：Kubernetes Master和node
* Kubernetes Master作用：
它是整个集群的管理者，具体的作用就是对整个集群节点
进行管理，通过主服务器向具体的节点发送诸如创建容器，自动部署，自动发布等职能，那么同时所有来自外侧的数据包都是有Kubernetes Master节点
来负责接收，再由它进行分配，在全局情况下，我们master主节点是一个独立的物理机 

* node
可以是一个独立的物理机也可以是虚拟机，在每个节点中涉及到一个特别重要也是k8s独有的概念Pod
它是整个k8s控制的最小单元。pod和容器又有什么关系呢


* Service
  该组件的作用就是将多个不同主机上的POD之间进行联通，使他们可以进行通信
  
* POD(豆荚)
![POD](images\豆荚.jpg)
  
POD于POD天然之间是无法进行交流的，如果要交流就必须通过另一个组件Service

  
POD到底是什么？里面装什么？
它里面虽然都是容器，但是在项目里面怎么用呢，这个不能一概而论。
根据项目的设计不同，POD的分割粒度也不同
 * 1. 小公司在进行集群部署的时候 一个POD就是一个完整的应用（里面有tomcat容器和redis或者mysql容器），部署一个POD就是部署了一个完整的应用，多个POD在部署完成后
   就形成了一个集群
 * 2. 还有一种用法就是在一个POD中只部署一种职能应用。
到底用哪种是根据我们项目的特性和资源的多寡来决定的，作为谷歌官方只给了POD的这样的设计，至于怎么用是非常灵活的，但是POD内部有一个特殊的容器Pause,这个Pause容器
  对于POD来水是必备的，并且是最基础的一个容器，它有两个只能：
      
Pause容器的两个职能
 * 1. 提供一个共享的网络命名空间（Pause的出现可以让属于POD内部的容器通过local加上不同的端口号就可以访问了，底层是复杂的网络知识）
![网络命名空间](images\POD提供网络命名空间.jpg)  
 * 2. 为当前POD提供一个共享的Volume挂载数据卷
**挂载数据卷**含义是可以将POD中的其他容器数据挂载到Pause容器中方便Pause管理，进而方便k8s管理。

* Label(标签)
 是一个说明性标签，在哪些POD上进行操作就是通过它来查找和筛选进而识别的，相当于每一个POD的别名
* Replication Controller(复制控制器)
存在于主节点上，它的作用是对POD的数量进行监控
如果我们需要3个红色POD，但目前只有2个，Replication Controller一看还少1个就会根据之前既定的规则
  来创建一个额外的副本放到我们的宿主机中，同时还能对POD进行实时监控，一旦某一个POD失去了响应，这个POD就会被剔除，如果还需要的化就会
  再创建一个新的。这个Replication Controller功能还是挺强大的，如果我们需要5个红色的标签的POD,只需要配置一下将3改为5即可，如何就会创建额外的2个POD
  这一切无需人工干预。

这些技术由谁来提供呢？
再这里每一个Node节点中需要安装三个应用程序
 * 1.Docker  这个执行Docker的命令
 * 2.kubelet 这个用于执行k8s相关的命令
 * 3.kube-proxy 之前提到提供跨主机跨容器进行交互的service组件依靠的就是这个程序
在k8s安装好后2和3的应用程序就存在

跨主机跨容器进行交互过程
有一个请求到了有tomcat的POD中，此时需要访问在另一个主机上的MySQL时，就会先把请求tomcat的请求转发给其所在node上的kube-proxy
然后再由其转发给另一个节点的mysql主机。
作为kube-proxy它就充当了多主机POD通信的代理人
Service是从逻辑上对POD进行了分组，但是底层仍然要通过kube-proxy进行跨主机通信

